# 大 O 表示法

知道算法的速度和占用的空间是很有用。这可以帮助你选择更好的算法来解决问题。

大 O 表示法可以让你对算法的运行时间和使用的内存量有一个大概的概念。有人说“算法在最糟糕的情况下需要 **O( n^ 2)** 的时间和使用 **O( n )** 的空间”的时候，他的意思是，它是有点慢，但是不u需要额外的内存。

一个算法的大 O 表示法通常通常是通过数学分析得来的。我们会掉过有关数学的部分，但是知道不同的值代表的意思是很有用。下面是一个很方便的表哥。 **n** 达标的是你要处理的数据的数量。例如，当对一个有 100 个数据的数组排序时， **n=100**。

大 O | 名称 | 描述
------| ---- | -----------
**O(1)** | 常数及 | **最好的** 不管有多少数据，算法都需要相同的时间。例如：通过索引从数组中取出一个元素。
**O(log n)** | 对数级 | **非常好** 这种类型的算法在每次迭代之后都会减少一半的数据量。如果你有 100 个数据，大概需要7步就可以找到需要的答案。如果是 1000 个数据的话，大概需要 10 次迭代。如果是 1000，000 个数据的话只需要 20 次迭代。对于大数据量来说，这已经是相当快的了。例如：二分搜索。
**O(n)** | 线性级 | **好** 如果有 100 个数据就需要100次迭代工作。数据翻倍的时候，算法就需要两倍的时间（200 次迭代工作）。例如：线性查找。
**O(n log n)** | 线性对数级 | **还可以** 比线性的遭一些，但还不差。例如：最快的通用排序算法。
**O(n^2)** | 二次方级 | **有点慢** 如果有 100 个数据，需要 100 ^ 2 = 10,000 次迭代工作。数据量翻倍的话需要的时间是四倍（因为 2 的平方是 4）。例如：循环内嵌，比如插入排序。
**O(n^3)** | 三次方级 | **糟糕** 如果有 100 个数据，需要 100 ^ 3 = 1000,000 次迭代。数据量范围的话，时间是9倍。例如：矩阵乘法。
**O(2^n)** | 指数级 | **非常糟糕** 要尽量避免这样的算法，但有时又没得选择。增加一点数据就会让时间翻倍。例如：旅行推销员问题。
**O(n!)** | 阶乘级 | **蜗牛速度** 毫不夸张的说，用这个做一件事情需要一百万年。

通常都不需要计算一个算法的大 O 是多少，直接使用直觉就可以。如果使用一个简单的循环来查找输入的 **n** 个元素，这个算法就是 **O( n )** 。如果代码里有两个嵌套的循环，那就是 **O( n^2 )** 。三个嵌套循环就是 **O( n^3 )，以此类推。

大 O 表示法仅仅是一个预估，并且只对比较大的 **n** 才有用。例如，对于 [插入排序](Insertion%20Sort/README-CN.markdown)来说，最糟糕的情况下算法的运行时间是 **O( n^3 )**。理论上来说这要比[归并排序](Merge%20Sort/README-CN.markdown)糟糕的多，归并排序的时间是 **O(n log n)**。但是对于小数据量来说，插入排序实际上更快，尤其是当数据有一部分是已经排好序的话。

如果你觉得这很困惑，不要让大 O 阻碍你太多。大多时候是用来比较两个算法哪个更好。最后你还是要测试在实际中哪个真的运行比较快。如果数据相对来说比较少的话，一个慢的算法可能在实际中更快。


