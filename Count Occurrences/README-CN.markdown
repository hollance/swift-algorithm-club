# 计算出现次数

目标：计算一个特定值在数组中出现的频率。

最显而易见的办法就是使用 [线性搜索](../Linear%20Search/README-CN.markdown) 从数组的开始一直找到结尾，记录需要查找的值出现的次数。这个是 **O(n)** 的时间复杂度的算法。

用[二分搜索](../Binary%20Search/README-CN.markdown) 的话，只需要 **O(log n)** 的时间。
然而，如果数组是有序的话做起来就可以更快了，

加入我们有下面的数组：

	[ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]

如果想知道 `3` 出现的次数，我们只要做一次常规的二叉搜索即可。结果是给出下面四个任何一个索引：

	[ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]
	           *  *  *  *

但是这还没有告诉我们还有多少个这样的 `3`。为了找出其他的 `3`，还需要对左右两边各自进行一次线性搜索。在大部分情况下这都会比较快，但是最糟糕的情况是——当数组全是 `3` —— 它还是需要 **O(n)** 的时间。

技巧就是用两个二叉搜索，一个用来找到 `3` 是从哪里开始的 （左边的边界），一个是用来找到它在哪里结束的（右边的边界）。

用代码实现就是这样的：

```swift
func countOccurrencesOfKey(_ key: Int, inArray a: [Int]) -> Int {
  func leftBoundary() -> Int {
    var low = 0
    var high = a.count
    while low < high {
      let midIndex = low + (high - low)/2
      if a[midIndex] < key {
        low = midIndex + 1
      } else {
        high = midIndex
      }
    }
    return low
  }
  
  func rightBoundary() -> Int {
    var low = 0
    var high = a.count
    while low < high {
      let midIndex = low + (high - low)/2
      if a[midIndex] > key {
        high = midIndex
      } else {
        low = midIndex + 1
      }
    }
    return low
  }
  
  return rightBoundary() - leftBoundary()
}
```

辅助方法 `leftBoundary()` 和 `rightBoundary()` 跟 [二分搜索](../Binary%20Search/README-CN.markdown) 非常像。最大的不同是当它找到了要搜索的关键词时，不会停止，而是继续找。

将代码拷贝到 playground 里进行测试吧：

```swift
let a = [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]

countOccurrencesOfKey(3, inArray: a)  // 返回 4
```

> **记住：** 如果用自己的数组的话，要确保数组是有序的！

让我们来看看这个例子吧，数组是：

	[ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]

为了找到左边的边界：我们从 `low = 0` 和 `high = 12` 开始。第一个中间的索引是 `6`：

	[ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]
	                    *

如果是一个普通的二叉搜索的话到这里就可以结束了，但是我们不只是要找 `3` 有没有出现——而是要找到它 *第一次* 在哪里出现。

既然这个算法和二叉搜索的规则是一样的，我们现在忽略掉右半边的数组，然后计算新的中间索引：

	[ 0, 1, 1, 3, 3, 3 | x, x, x, x, x, x ]
	           *

我们又找到了一个 `3`，并且它就是第一个出现的了。但是算法还不知道，我们要继续拆分数组：

	[ 0, 1, 1 | x, x, x | x, x, x, x, x, x ]
	     *

还是没有结束，继续拆分，但是这次用右半边：

	[ x, x | 1 | x, x, x | x, x, x, x, x, x ]
	         *

数组不能再继续拆分，也就是说我们在索引 3 的位置找到了左边的边界。

现在我们要重新开始，来试试找右边的边界。它们俩非常像，所以只展示给你不同的地方：

	[ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]
	                    *

	[ x, x, x, x, x, x, x | 6, 8, 10, 11, 11 ]
	                              *

	[ x, x, x, x, x, x, x | 6, 8, | x, x, x ]
	                           *

	[ x, x, x, x, x, x, x | 6 | x | x, x, x ]
	                        *

右边界在索引 7 的位置。两个边界的差值就是我们要找的 `3` 出现的次数 7 - 3 = 4。

每个二叉搜索都要执行4步，所以整个算法是 8 步。对于一个只有 12 个元素的数组来说不是一个很好的收益，但是数组越大，效果就会越明显。对于一个有 1,000,000 个元素的有序数组来说，只要 2 x 20 = 40 步就可以算出任何特定值出现的次数。

顺便提一下，如果要找的值没有在数组中出现，那么 `rightBoundary()` 和 `leftBoundary()` 就会返回一样的值，所以他们的差值就是 0。

这是一个如何利用改进的基本二叉搜索来解决其他算法的问题。当然，它要求数组是有序的。

*作者：Matthijs Hollemans 翻译：Daisy*


