# 哲学家就餐问题

哲学家就餐问题算法在 Swift 中有实现（用来说明同步问题和解决它们的技术的并发算法设计在 Swift 中用的是 GCD 和信号量）


# 简介

在计算机科学中，哲学家就餐问题经常用作说明同步问题和解决它们的技术的并发算法设计的示例问题。

最初是由 Edsger Dijkstra 在学生考试作业中在 1965 年以计算机竞争访问磁带驱动设备的形式提出来的。之后没多久，Tony Hoare 提出了这个问题现在的公式。

现在 Swift 的实现是在 Chandy/Misra 解决方法的基础上实现的，用 GCD 分发和信号量来实现跨平台。

# 问题阐述

五个沉默的哲学家坐在一张有一碗意大利面的圆桌上。叉子放在两个相邻的哲学家之间。

每个哲学家要么选择思考要么选择吃。但是，只有当哲学家左右两边都有叉子的时候才可以吃。每个叉子只能被一个哲学家拿着，所以哲学家只有在没有人拿着叉子的时候才能用叉子。在一个哲学家吃完之后，需要放下两个叉子，这样别的哲学家才能用。当叉子可用的时候，哲学家可以选择拿左边的叉子也可以选择拿右边的叉子，但是在拿到两个叉子之前不能吃。

吃和剩下的意大利面的多少和是不是能够吃得下无关；前提是有无限的意大利面供应和足够的肚子空间可以吃。

问题是如何设计一个行为规则（并发算法）让所有的哲学家都不挨饿；即每个哲学家可以一直在吃和思考之间切换，前提是没有哲学家知道别人什么时候想吃还是思考。

下面是一个餐桌的解释：

![Dining Philosophers table](https://upload.wikimedia.org/wikipedia/commons/7/7b/An_illustration_of_the_dining_philosophers_problem.png)


# 解决方法
 
这个景点算法有很多不同的解决方案。基于 Chandy/Misra 解决方案的 Swift 的实现更加通用，它允许任务数量的代理在一个没有中央机构控制资源锁定和序列化的情况下在完全分布式的场景竞争任意数量的资源。

然而，有一个非常重要的需要注意的地方时这个解决方案违反了 “哲学家彼此之间不能说话” 的前提（基于要求的信息）。


# 描述

对于每一对竞争资源的哲学家来说，创建一个叉子然后将它交给 ID （n 代表代理 Pn）的哲学家。每个叉子要么是脏的要么是干净的。开始的时候，叉子都是脏的。
当哲学家想要一组资源的时候（即，吃），也就是说这个哲学家要从他的竞争邻居中获得叉子。对于哲学家没有获得的叉子，他们就需要发送一个请求信息。
当有叉子的哲学家收到一个请求信息时，如果叉子是干净的，那么他就拿着叉子，但是如果脏了的话就要放弃了。如果哲学家要放下叉子之前要先将叉子弄干净。
当一个哲学家吃完之后，他所有的叉子都是脏的。如果另外一个哲学家请求了其中一个叉子，刚刚吃完的哲学家就要洗干净叉子然后将叉子放过去。
这个解决方法可以容纳大量的并发，并且可以解决大量的问题。

它也解决了饥饿的问题。干净/脏 标签是以优先满足最 “饿” 的进程的方式来工作的，一个缺点就是处理刚刚 “吃过”。可以通过不允许哲学家在两次吃之间没有其他哲学家吃来解决。Chandy 和 Misra 的解决方法比这个更灵活，但是那个方向上还是值得一试的。

在他们的分析中，他们是从叉子的分配和他们的干净/脏的状态来得出一个偏好级别系统的。他们表示这个系统可以用一个无循环图来描述，如果这样的话，基于这个协议的操作就不会变成一个循环图。这就保证了不会发生死锁。然而，如果系统开始的时候是一个完美的对称状态，比如所有的哲学家都拿着他们左边的叉子，那么图最后就会变成循环的，他们的解决方法就不可便面的形成死锁。初始化系统的时候让小 ID 的哲学家的叉子是脏的可以保证图在初始化的时候不是循环的。


# Swift 实现

Chandy/Misra 解决方案在 Swift 3.0 里的实现是基于 GCD 和信号量技术的，构建在 macOS 和Linux 上。

代码是基于用来持有 DispatchSemaphore 数组的 ForkPair 结构和将一组叉子和每个哲学家关联起来的 Philosopher 结构。

ForkPair DispatchSemaphore 静态数组用来提醒邻居哲学家将叉子放到桌子上的

后台的 DispatchQueue 用来使得任何哲学家可以在后台异步地运行，全局的 DispatchSemaphore 用来让主线程等待以及让哲学家可以一直在思考和吃的循环中进行切换。

# 参考

[哲学家就餐问题 维基百科](https://en.wikipedia.org/wiki/Dining_philosophers_problem)

作者：Jacopo Mangiavacchi 翻译：Daisy


