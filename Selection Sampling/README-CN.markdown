# 选取样本

目标：从一个具有 *n* 个元素的集合中随机选择 *k* 个元素。

假如有 52 张扑克牌，需要从中随机抽取 10 张。这个算法就是用来做这个的。

下面是一个很非常快速的版本：

```swift
func select<T>(from a: [T], count k: Int) -> [T] {
  var a = a
  for i in 0..<k {
    let r = random(min: i, max: a.count - 1)
    if i != r {
      swap(&a[i], &a[r])
    }
  }
  return Array(a[0..<k])
}
```

就像在 [各种算法](../Shuffle/README-CN.markdown) 中经常出现的一样，它将数组分成两部分，第一部分包含选择的元素，第二部分是所有剩下的元素。

下面是一个例子，加入数组是这样的：

	[ "a", "b", "c", "d", "e", "f", "g" ]
	
我们想要选择 3 个元素，所以 `k = 3` 。在循环中，`i` 初始值是 0，所以它指向 a。

	[ "a", "b", "c", "d", "e", "f", "g" ]
	   i

计算一个从 `i` 到 `a.count` 之间的随机数，`a.count` 是数组的大小。假如它是 4，现在讲 `a` 和 `e` 交换，`e` 是在索引 4 的元素，然后将 `i` 前移：
	[ "e" | "b", "c", "d", "a", "f", "g" ]
	         i

`|` 符号用来将数组分成两部分。`"e"` 是我们选择的第一个元素。符号右边的元素都是我们还要查找的。

再计算一个 `i` 和 `a.count` 之间的随机数，因为 `i` 已经变了，所以随机数不可能会比 1 小。所以永远不会讲 `"e"` 再换回去。

假如随机数是 6，然后我们将 `“b”` 和 `“g”` 互换：

	[ "e" , "g" | "c", "d", "a", "f", "b" ]
	               i

还要再选一个随机数，假如它还是 4 吧。将 `"c"` 和 `"a"` 互换，我们就得到了最终的结果：

	[ "e", "g", "a" | "d", "c", "f", "b" ]

这就结束了，很简单是吧。这个函数的时间复杂度是 **O(k)**，因为只要我们选了 *k* 个元素就结束了。

下面是一个可选择的算法，叫做 “蓄水池抽样”：

```swift
func reservoirSample<T>(from a: [T], count k: Int) -> [T] {
  precondition(a.count >= k)

  var result = [T]()      // 1
  for i in 0..<k {
    result.append(a[i])
  }

  for i in k..<a.count {  // 2
    let j = random(min: 0, max: i)
    if j < k {
      result[j] = a[i]
    }
  }
  return result
}
```

分为两步：

1. 从原始数组中拿 k 个元素放到 result 数组中。这叫做 蓄水池。
2. 从剩下的元素中随机选择元素来替换蓄水池中的元素。

这个算法的时间复杂度是 **O(n)**，所以它比刚开始讲的方法要慢一些。它最大的好处是可以用于由于太大而不能在内存中存放的数组，即使不知道数组的大小也可以（在 Swift 中，这可能有点类似需要从文件中读取元素的懒加载）。

前面的两个算法都由一个缺点：它们不会保留元素在的原始顺序。在刚开的时候 `"a"` 是在 `"e"` 的前面的，但是后来就不是这样了。如果对于你的应用来说这是一个问题的话，就不能由这个方法了。

下面是一个可以保留原始顺序的方法，但是它更复杂：

```swift
func select<T>(from a: [T], count requested: Int) -> [T] {
  var examined = 0
  var selected = 0
  var b = [T]()
  
  while selected < requested {                          // 1
    examined += 1
    
    let r = Double(arc4random()) / 0x100000000          // 2
    
    let leftToExamine = a.count - examined + 1          // 3
    let leftToAdd = requested - selected

    if Double(leftToExamine) * r < Double(leftToAdd) {  // 4
      selected += 1
      b.append(a[examined - 1])
    }
  }
  return b
}
```

这个算法用概率来决定是否将数组包含进要选择的元素中：

1. 遍历整个数组。直到从 *n* 的集合中选择了 *k* 个元素。*k* 叫做 `requested`，*n* 是 `a.count`。

2. 计算一个 0 到 1 之间的随机数，使得 `0.0 <= r < 1.0`。不包括 1.0；因为我们不会想要它等于 1。这也是为什么我们要将 `arc4random()` 除以 `0x100000000`，而不是 `0xffffffff` 的原因。

3. `leftToExamine` 是告诉我们还有多少个元素还没有查找。`leftToAdd` 是还要选择多少个元素才能完成。

4. 这里就是产生魔法的地方。就像我们扔硬币一样。如果是头朝上，就将当前数组元素放到选择里，如果不是，就跳过它。

很有趣吧，虽然我们使用了概率，这个方法也能保证输出的数组中总是正好有 *k* 个元素。

让我们再看看前面的同一个例子。输入数组是：

	[ "a", "b", "c", "d", "e", "f", "g" ]

循环是按顺序遍历数组的每个元素的，所以我们从 `"a"` 开始。得到一个 0 到 1 之间的随机数，假如它是 0.841。公式 `// 4` 将剩下的还未检索的元素的个数乘以这个随机数，在上面的例子还有 7 个没有检查的数，所以结果是：

	7 * 0.841 = 5.887

将它与 3 比较，因为我们想要选 3 个元素。因为 5.887 比 3 大，所以我们跳过 `"a"` 直接到 `"b"`。

再拿一个随机数，假如它是0.212。现在只剩下 6 个元素了，所以公式是：

	6 * 0.212 = 1.272

这个值比 3 小，所以我们将 `"b"` 放到选择里。这是我们选择的第一个元素，还有两个要选择。

到下一个元素，`"c"`。随机数是 0.264，结果是：

	5 * 0.264 = 1.32

现在只需要再选两个元素，所以数字必须小于2。正好它小于 2，所以将 `"c"` 加到选择里。现在所有的选择是 `["b"， "c"]`.

现在还要再选一个就可以了，但是还有 4 个没有查找的候选者。加入下一个随机数是：0.718。公式如下：

	4 * 0.718 = 2.872

对于最后一个要选择的元素的数字必须小于 1，因为只剩下一个需要被选择。它比 1 大，所以我们跳过 `"d"`。只剩下三个了 —— 会在我们找完数组之前成功吗？

随机数是：0.346。公式是：

	3 * 0.346 = 1.038
	
只大了一点点。跳过 `"e"`，只有两个候选了...

注意到现在我们实际上在处理一个硬币问题：如果随机数小于 0.5，我们就选择 `"f"`，然后就结束了，如果大于0.5，就继续到下一个元素。假如随机数是 0.583：

	2 * 0.583 = 1.166

跳过 `"f"` 然后检查最后一个元素。不管随机数是什么，我们都必须选择 `"g"` 这个元素，否则我们就没有完成选择足够元素的任务，这个算法也就不行了。

假如最后的随机数是 0.999 （记住，随机数不可能大于或者等 1.0)。实际上，不管我们这里选什么，公式给出来的结果都会比 1 小：

	1 * 0.999 = 0.999

如果还没有选满的话，最后一个元素就一定会被选择。最终的选择结果是 `[ "b", "c", "g" ]`。元素始终保持着它们原来的相对顺序，因为我们是从左到右来检查数组的。

或许你还没有被说服吧...假如我们一直拿到的随机数都是 0.999 呢（最大的可能数），是不是还能廁 3 个元素？好吧，让我们来做做数学吧：

	7 * 0.999 = 6.993     is this less than 3? no
	6 * 0.999 = 5.994     is this less than 3? no
	5 * 0.999 = 4.995     is this less than 3? no
	4 * 0.999 = 3.996     is this less than 3? no
	3 * 0.999 = 2.997     is this less than 3? YES
	2 * 0.999 = 1.998     is this less than 2? YES
	1 * 0.999 = 0.999     is this less than 1? YES

它始终都是能工作的！这是否说明数组后面的元素比前面的元素有更高的概率被选择呢？不，所有的元素都由同等的机会被选择。（不要只听我说，在 playground 里试试吧）

下面是如何测试算法的例子：

```swift
let input = [
  "there", "once", "was", "a", "man", "from", "nantucket",
  "who", "kept", "all", "of", "his", "cash", "in", "a", "bucket",
  "his", "daughter", "named", "nan",
  "ran", "off", "with", "a", "man",
  "and", "as", "for", "the", "bucket", "nan", "took", "it",
]

let output = select(from: input, count: 10)
print(output)
print(output.count)
```

第二个算法的时间复杂度是 **O(n)**，因为它可能要遍历整个数组。

> **注意：** 如果 `k > n/2`，那么更有效的一个方式是移除 `k` 个元素。

基于 Dr. Dobb 的杂志上的 Algorithm Alley 算法，1993.10

*作者： Matthijs Hollemans 翻译：Daisy*


