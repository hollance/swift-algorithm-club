# B 树

B 树是一个自平衡搜索树，它的节点可以多与两个的子节点。

### 特性

 顺序为 *n* 的 B 树满足一下特征：

 - 每个节点最多有 *2n* 个关键字
 - 每个节点（除了根节点） 最少有 *n* 个关键字
 - 每个非叶子节点有 *k+1* 个子节点的 *k* 个关键字
 - 所有节点里的关键字是按升序排序的
 - 非叶子节点的两个关键字 *k* 和 *l* 之间的子树包含所有的 *k* 和 *l* 之间的关键字。
 - 所有的叶子都出现在同一级。

关键字从 1 到 20 的二序 B 树看起来是下面这样的：

![A B-Tree with 20 keys.](Images/BTree20.png)

### 用代码表示 B 树

```swift
class BTreeNode<Key: Comparable, Value> {
  unowned var owner: BTree<Key, Value>
  
  fileprivate var keys = [Key]()
  var children: [BTreeNode]?
  
  ...
}
```

一个节点的主要部分是两个数组：
 - 一个数组包含关键字
 - 一个数组包含子节点

![Node.](Images/Node.png)

节点也有一个他们所属树的引用. 
这是必要的因为节点必须要知道树的顺序。

*注意：包含子节点的数组是可选的。因为叶子节点没有子节点。*

## 搜索

1. 对关键字 `k` 的搜索是从根节点开始的
2. 对节点的关键字执行一个线性搜索，知道找到关键字 `l` 大于等于 `k`。
3. 如果 `k = l`，那么我们就找到了
4. 如果 `k < l`：
	 - 如果所在的节点不是叶子节点，那么我们就进入到 `l` 的左节点，然后再执行步骤 3 - 5
	 - 如果是叶子节点，那么 `k` 不在树上
5. 如果到了数组的末尾：
	 - 如果不是叶子节点，就堆节点的最后的子节点执行步骤 3 - 5
	 - 如果是叶子节点，那么 `k` 在树上

### 代码

`value(for:)` 方法搜索给定的关键字，如果在树上的话，返回跟它相关的值，否则返回 `nil`。

## 插入

关键字只能插入到叶子节点。

1. 对我们想要插入的 `k` 执行一个搜索。
2. 如果没有找到它并且在叶子节点，我们就可以插入它。
 - 如果在搜索之后我们在比 k 大的位置：  
   在 `l` 之前插入 `k`。
 - 否则：  
   在 `l` 之后插入 `k`。
 
插入之后我们应该检查节点里的关键字是不是在争取额的范围内。
如果有多余 `order*2` 的关键字在节点里，我们就要拆分这个节点。

#### 拆分节点
 
1. 将要拆分的节点的中间的关键字往上移到它的父节点（如果有的话）。
2. 如果它没有父节点（它是根节点），那么就创建一个新的根节点，然后插入到根节点里。同时把 旧的根节点放到新根节点的左节点
3. 通过移动在中间关键字之后的关键字（还有子节点，如果不是叶子节点的话）的到心节点的方式将节点分成两部分
4. 将心节点作为我们往上移动的关键字的右节点。

在拆分节点之后，它的父节点也可能包含太多的关键字，所以我们也要将它进行拆分。
在最差的情况下，拆分要一直往上直到根节点（这样的话，树的高度会增加）。

一序树的添加是这样的：

![Splitting](Images/InsertionSplit.png)

### 代码

方法 `insert(_:for:)` 做的是插入操作。
在插入一个关键字之后，要递归的检查每个节点的子节点包含的关键字的个数。  
如果节点有太多的关键字，它的父节点要堆它调用 `split(child:atIndex:)` 方法。

根节点是由树自己来检查。
如果根节点在插入之后有太多的节点，对树调用 `splitRoot()` 方法。

## 删除

关键字只能从叶子节点移除。

1. 对想要删除的关键字 `k` 执行搜索。
2. 如果找到了：
   - 如果在叶子节点： 
     可以移除这个关键字
   - 否则： 
     用紧挨着它的前一个 `p` 来覆盖 `k`，然后从叶子节点移除 `p`。

在关键字从节点移除厚，我们应该检查节点是否有足够的关键字。  
如果节点的关键字少于树的序，那么我们就要移动一个关键字给它。
或者从它的兄弟节点合并一个过来。

#### 移动一个关键字到子节点

如果有问题的节点的最近的兄弟有比树的序多的节点，我们就要堆树执行这个操作，否则我们应该将它的兄弟的其中一个节点合并过来。

假设我们要修复的 `c1` 在父节点的子节点数组的索引 `i` 上。

如果在索引 `i-1` 的子节点 `c2` 有比树的序更多的节点：

1. 将索引 `i-1` 的关键字从父节点移动到子节点 `c1` 的关键字数组的索引 `0` 的位置。
2. 将 `c2` 的最后一个关键字移动到父节点的索引 `i-1` 的位置
3. （如果 `c1` 是叶子节点）将最后的子节点从 `c2` 移动到 `c1` 的子节点数组的索引 `0` 的位置。

否则： 

1. 将索引 `i` 的关键字从父节点移动到子节点 `c1` 的关键字数组。
2. 将 `c2` 的第一个关键字移动到父节点的关键字数组的索引 `i` 的位置。
3. （如果 `c1` 不是叶子）将 `c2` 的第一个子节点移动到 `c1` 的子节点数组。

![Moving Key](Images/MovingKey.png)

#### 合并两个节点

假设我们想合并父节点的子节点数组索引 `i` 的子节点 `c1`。

如果 `c1` 有左兄弟 `c2`：

1. 将父节点的索引 `i-1` 的关键字移动到 `c2` 的关键字数组的最后。
2. 将关键字和子节点（如果不是叶子节点的话）从 `c1` 移动到 `c2` 的关键字和子节点的最后。
3. 将父节点索引 `i-1` 位置的子节点移除。

如果 `c1` 只有一个右兄弟 `c2`：

1. 将父节点中索引 `i` 的关键字移动到 `c2` 的关键字数组的开头
2. 将关键字和子节点（如果不是叶子节点的话）从 `c1` 移动到 `c2` 的关键字和数组的开头。
3. 将索引 `i` 的子节点从父节点移除。

在合并之后父节点可能会有很少的关键字，所以在最差的情况下，合并也需要往上走到根节点，这样的话，树的高度就会变小。

![Merging Nodes](Images/MergingNodes.png)

### 代码

- `remove(_:)` 方法将给定的关键词从树中移除。在关键字被删除后，每个节点的子节点都要检查关键字的个数。如果子节点的关键字的个数少于树的序，就要调用 `fix(childWithTooFewKeys:atIndex:)` 方法。

- `fix(childWithTooFewKeys:atIndex:)` 方法用什么方法来修复子节点（是通过移动关键字还是合并），然后根据情况调用 `move(keyAtIndex:to:from:at:)` 或 
  `merge(child:atIndex:to:)`。

## 参考

[维基百科](https://en.wikipedia.org/wiki/B-tree)  
[GeeksforGeeks](http://www.geeksforgeeks.org/b-tree-set-1-introduction-2/)

*作者：Viktor Szilárd Simkó 翻译：Daisy*


