# 布隆过滤器

## 介绍

布隆过滤器是一种空间高效的用来告诉你元素是否在集合中的数据结构。

这是一种概率数据结构：对布隆过滤器的查询要么返回 `false`，意思是元素绝对不在集合里，或者 `true`，意思是元素 *可能* 在集合里。

有极小的概率会误报，这就是说查询返回 `true`，但元素实际上不在集合里。但是绝不会有假阴性：如果查询返回 `false`，就能保证元素不在集合中。

所以布隆过滤器告诉你的是，“绝不可能” 或者“可能是”。

首先，这看起来没什么用。但是，在如缓存过滤和数据同步的应用中是很重要的。

与散列表相比，布隆过滤器的一个优点是，布隆过滤器维护固定大小的内存和固定时间的插入和搜索。对于有许多元素的集合来说，散列表和布隆过滤器之间的性能差异是明显的，如果你不需要没有误报的保证的话，这是一个可行的选项。

> **注意：** 与散列表不同的是，布隆过滤器不会实际存储对象。它只记住你有哪些对象（有一定程度的不确定性），没有那些对象。

## 插入对象到集合里

布隆过滤器基本上是一个固定长度的[位向量](../Bit%20Set/README-CN.markdown)，也就是位数组。当插入对象的时候，我们将某些位设置为 `1`，当查询对象的时候，检查某些事是 `0` 还是 `1`。这两个操作都使用散列函数。

为了在过滤器中插入元素，会对元素用不同的散列函数进行散列操作。每个散列函数都返回一个与数组中的索引对应的值。然后将这些索引设置为 `1` 或者 true。

例如，假设这就是我们的位数组。有 17 位，初始的时候都是 `0` 或者 false：

	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]

现在我们想插入字符串 `"Hello world!"` 到布隆过滤器中。对这个字符串应用两次散列散列函数。第一个返回的值是 1999532104120917762，通过与数组的长度求余的方式来将这个值与数组的索引对应起来：`1999532104120917762 % 17 = 4`。这就意味着我们将索引 4 设为 `1` 或者 true：

	[ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]

然后再对原来的字符串做一次散列，但是这次我们用的是不同的散列函数。它返回的值是 9211818684948223801，对 17 求余是 12，然后我们将索引 12 的位也设置为 `1`：

	[ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 ]

这两个 1-位足以告诉布隆过滤器它现在包含字符串 `"Hello world!"`。当然，它并不包含实际的字符串，所以你不能叫布隆过滤器：“给我一个你包含的所有对象的列表”。它所包含的就是一堆 1 和 0。

## 查询集合

查询，和插入相似，通过对希望查询的值进行散列活的一些数组索引，然后检查所有这些位是不是 `1`。如果有一个位不是 `1`，那么元素就肯定没有被插入进来并且查询返回 `false`。如果所有的位都是 `1`，查询就返回 `true`。

例如，如果我们查询字符串 `"Hello WORLD"`，返回的第一个散列值是 5383892684077141175，对 17 求余得到 12。这位是 `1`，但是第二个散列函数返回的是 5625257205398334446，这与数组的索引 9 对应。这位是 `0`。这就意味着字符串 `"Hello WORLD"` 不在过滤器中并且查询返回 `false`。

第一个散列函数对应的是 `1` 位实际上有点巧合（这与两个字符串以 `"Hello "` 开始无关）。有很多这样的巧合会导致 “冲突”。如果有冲突，查询就可能错误的返回 `true`，即使元素没有被插入的话 —— 引出了之前提到的误报的问题。

我们再插入一些其他的元素，`"Bloom Filterz"`，会设置索引 7 和 9 的位。现在数组是这样的：

	[ 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0 ]

如果再查询 `"Hello WORLD"`，过滤器发现位 12 是真， 位 9 也是真。它就会报告说 `"Hello WORLD"` 确实在集合里，即使它不在...因为我们没有插入过这个字符串。这是一个误报。这个例子说明为什么布隆过滤器不会说：“绝对是”，而仅仅是“可能是”。

可以通过使用具有更多位的数组和使用更多的散列函数来解决这个问题。当然，散列函数用的越多，布隆过滤器就会越慢。所以必须要达到一个平衡。

对于布隆过滤器来说删除是不可能的，因为任何一位可能属于多个元素。一旦你添加了一个元素，它就在那里了。

布隆过滤器的性能是 **O(k)**，**k** 是散列函数的个数。

## 代码

代码非常直观。在初始化的时候，内部的位数组给定了一个固定的长度，一旦初始化就不能再变了。

```swift
public init(size: Int = 1024, hashFunctions: [(T) -> Int]) {
	self.array = [Bool](repeating: false, count: size)
  self.hashFunctions = hashFunctions
}
```

在初始化的时候需要指定一些散列函数。用什么散列函数取决于要添加到集合里的元素的数据类型。可以在 playground 里看到一些例子和测试 —— `djb2` 和 `sdbm` 散列函数 是给字符串用的。

插入只是将对应的位变为 `true`：

```swift
public func insert(_ element: T) {
  for hashValue in computeHashes(element) {
    array[hashValue] = true
  }
}
```

这里用到 `computeHashes()` 函数，它循环遍历指定的 `hashFunctions` 然后返回索引的数组：

```swift
private func computeHashes(_ value: T) -> [Int] {
  return hashFunctions.map() { hashFunc in abs(hashFunc(value) % array.count) }
}
```

查询就检查在散列值里的位是 `true`：

```swift
public func query(_ value: T) -> Bool {
  let hashValues = computeHashes(value)
  let results = hashValues.map() { hashValue in array[hashValue] }
	let exists = results.reduce(true, { $0 && $1 })
  return exists
}
```

如果你是从另一种命令式语言中过来的，你可能会注意到在 `exists` 等式里的不一样的语法。Swift 中使用函数范式来让代码更加简洁易读，在这个例子中，`reduce` 是比 `for` 循环更简洁的检查所有的位是否是 `true` 的方法。

*作者 Jamil Dhanani 编辑：Matthijs Hollemans 翻译：Daisy*


