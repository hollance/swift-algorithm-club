# 位集合

固定大小的 *n* 位系列。也叫做位数组或者位向量。

为了保存为真或假的东西可以用 `Bool`。每个程序员都知道这个...但是如果想要记住 10,000 个为真或假的东西？

可以弄一个 10,000 个布尔值的数组，但是也可以直指核心，用 10,000 个位来代替。在64-位 CPU 上面，10,000 位只需要不到 160 个 `Int` 就够了，所以它更省空间。

因为对单个位的操作有点复杂，所以可以用 `BitSet` 来隐藏脏活部分。

## 代码

位集合是对数组的一个简单封装。数组不不存储单个的位，而是存储叫做 “字” 的大整数。`BitSet` 的主要工作就是将位对应到正确的字上面。

```swift
public struct BitSet {
  private(set) public var size: Int

  private let N = 64
  public typealias Word = UInt64
  fileprivate(set) public var words: [Word]

  public init(size: Int) {
    precondition(size > 0)
    self.size = size

    // Round up the count to the next multiple of 64.
    let n = (size + (N-1)) / N
    words = [Word](repeating: 0, count: n)
  }
```

`N` 是字的位大小。因为我们将位存储在一个无符号64-位整数的列表里，所以它的大小是64（很容易就可以将 BitSet 使用32-位字来代替）。

如果这样写：

```swift
var bits = BitSet(size: 140)
```

那么 `BitSet` 分配一个有三个字的数组。每个字有 64 位，所以三个字可以存储 192 位。我们只需要 140 位，所以浪费了一些位空间（但是我们不能用少于整个字）。

> **注意：** `words` 数组的第一个入口是最重要的字，这些字在数组中是以低端字节顺序存储的。

## 查找位

大部分 `BitSet` 的操作都是讲索引作为位的参数，所以有方法能够找到是哪个字中包含索要查找的位是非常有用的。

```swift
  private func indexOf(_ i: Int) -> (Int, Word) {
    precondition(i >= 0)
    precondition(i < size)
    let o = i / N
    let m = Word(i - o*N)
    return (o, 1 << m)
  }
```

`indexOf()` 函数返回字在数组中的索引，以及一个 ”掩码“ 来标识位在字中的哪个位置。

例如，`indexOf(2)` 返回元组 `(0, 4)`，因为位 2 在第一个字（索引 0），掩码是 4。用二进制标识的话，掩码就是下面这样的：

	0010000000000000000000000000000000000000000000000000000000000000

1 代表的就是字中的第二个位。

> **注意：** 记住所有东西都是以低端字节顺序显示的，包括位本身。位 0 在左边，位 63 在右边。

另一个例子：`indexOf(127)` 返回元组 `(1, 9223372036854775808)`。它是第二个字的最后一位。掩码是：

	0000000000000000000000000000000000000000000000000000000000000001

注意到了吗，掩码始终是 64 位的，因为我们每次都是查找一个字。

## 设置和获取位

现在我们知道去哪里找到位了，将它设置成 1 也就非常简单了：

```swift
  public mutating func set(_ i: Int) {
    let (j, m) = indexOf(i)
    words[j] |= m
  }
```

查找字的索引和掩码，然后将字和掩码执行位或操作。如果位原来是 0，它就会变成 1。如果它之前就是 1，那么它还是 1。

清除位 —— 例如，将它变成 0 —— 也很简单：

```swift
  public mutating func clear(_ i: Int) {
    let (j, m) = indexOf(i)
    words[j] &= ~m
  }
```

与位或不同的是，我们现在用的是和掩码的逆做位与操作。所以如果掩码是 `00100000...0`，那么它的逆是 `11011111...1`，除了我们想要设置为 0 的位之外所有的位都是 1。由于 `&` 工作的方式，除了要设置为 0 的位之外其他所有的位都不变化。

想要知道一个位是否被设置了，还是使用位与操作，但是这次不与逆做操作：

```swift
  public func isSet(_ i: Int) -> Bool {
    let (j, m) = indexOf(i)
    return (words[j] & m) != 0
  }
```

我们可以添加一个下标方法来让这一切都变得更自然一些：

```swift
  public subscript(i: Int) -> Bool {
    get { return isSet(i) }
    set { if newValue { set(i) } else { clear(i) } }
  }
```

现在可以这样写了：

```swift
var bits = BitSet(size: 140)
bits[2] = true
bits[99] = true
bits[128] = true
print(bits)
```

这会打印出140-位 `BitSet` 的三个字的所有信息：

```swift
0010000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000010000000000000000000000000000
1000000000000000000000000000000000000000000000000000000000000000
```

还有一个好玩的事情就是翻转位。这会将 0 变成 1，1 变成 0。下面是 `flip()`：

```swift
  public mutating func flip(_ i: Int) -> Bool {
    let (j, m) = indexOf(i)
    words[j] ^= m
    return (words[j] & m) != 0
  }
```

这里用的是剩下的位运算符，异或来做翻转。函数也返回新的位值。

## 忽略未使用的位

许多 `BitSet` 函数是非常容易实现的。例如，`clearAll()`，将所有的位设为 0：

```swift
  public mutating func clearAll() {
    for i in 0..<words.count {
      words[i] = 0
    }
  }
```

还有一个是 `setAll()` 将所有的位都设为 1。然而，这必须要处理一个小问题。

```swift
  public mutating func setAll() {
    for i in 0..<words.count {
      words[i] = allOnes
    }
    clearUnusedBits()
  }
```

首先，将数组中所有的字都设为全 1。数组现在是这样的：

```swift
1111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
```

但这是不对的...因为我们没有使用最后一个字的全部位，需要将剩下那些位设为 0：

```swift
1111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
1111111111110000000000000000000000000000000000000000000000000000
```

现在我们只有 140 个 1 位，而不是 192 个。最后一个字没有完全被使用意味着对于最后一个字始终要特殊处理。

将这些 ”剩下的“ 位设为 0 就是 `clearUnusedBits()` 辅助方法做的。如果 `BitSet` 的大小不是 `N` 的倍数（例如，64），那么我们就要清除那些没有使用的位。如果我们不这样做的话，两个不同大小的 `BitSet` 之间的位运算会出错（下面是例子）。

这里使用了一些高级的位操作，所以要仔细看哦：

```swift
  private func lastWordMask() -> Word {
    let diff = words.count*N - size       // 1
    if diff > 0 {
      let mask = 1 << Word(63 - diff)     // 2
      return mask | (mask - 1)            // 3
    } else {
      return ~Word()
    }
  }

  private mutating func clearUnusedBits() {
    words[words.count - 1] &= lastWordMask()   // 4
  }  
```

下面是一步步介绍它做了什么：

1） `diff` 是 ”剩下的“ 位的个数。在上面的例子中是 52，因为 `3*64 - 140 = 52`

2）创建一个除最高位为 1 之外全为 0 的 掩码。在我们的例子中，是这样的：

	0000000000010000000000000000000000000000000000000000000000000000

3) 减 1 变成:

	1111111111100000000000000000000000000000000000000000000000000000

然后把高位加回来得到：

	1111111111110000000000000000000000000000000000000000000000000000

现在在字中有 12 位 1 了，因为 `140 - 2*64 = 12`。

4) 最后，将所有更高位的位关掉。最后一个字中剩下的位现在都变成了 0。

这个在设么地方重要的一个例子是，将两个不同大小的 `BitSet` 连接到一起的时候。为了说明，我们用 两个 8 位置的位或运算来举例子：

	10001111  size=4
	00100011  size=8

第一个只用了 4 位；第二个用了 8 位。第一个本来应该是 `10000000`，但是我们假装我们忘记了清除这些位。这两个值之间的位或的结果是：

	10001111  
	00100011  
	-------- OR
	10101111

这是错误的，因为两个 1 位是不应该出现在这里的。正确的方式应该是这样的：

	10000000       先把未用到的位设为 0
	00100011  
	-------- OR
	10100011

下面是 `|` 运算符的实现：

```swift
public func |(lhs: BitSet, rhs: BitSet) -> BitSet {
  var out = copyLargest(lhs, rhs)
  let n = min(lhs.words.count, rhs.words.count)
  for i in 0..<n {
    out.words[i] = lhs.words[i] | rhs.words[i]
  }
  return out
}
```

我们是将整个字进行 `|` 操作，而不是单个位。这样的话就太慢了！如果左边和右边的位数不一样的话就还需要做一些额外的工作：将其中大的 `BitSet` 拷贝到结果 `out` 变量中，然后将它和小的 `BitSet` 连接起来。

例如：

```swift
var a = BitSet(size: 4)
a.setAll()
a[1] = false
a[2] = false
a[3] = false
print(a)

var b = BitSet(size: 8)
b[2] = true
b[6] = true
b[7] = true
print(b)

let c = a | b
print(c)        // 1010001100000000...0
```

位与（`&`）、位或（`^`）和逆 (`~`) 也是类似的实现。

## 计算 1 位的个数

为了计算设置为 1 的位数，我们可以扫描整个数组 —— 一个 **O(n)** 的操作 —— 但是还有更聪明的方法：

```swift
  public var cardinality: Int {
    var count = 0
    for var x in words {
      while x != 0 {
        let y = x & ~(x - 1)  // find lowest 1-bit
        x = x ^ y             // and erase it
        ++count
      }
    }
    return count
  }
```

当你写 `x & ~(x - 1)` 的时候，会返回一个只有一位被设置的薪值。这就是最低的那一位。例如，拿 8 位的值来举例（我再一次使用左边最重要的位来展示这个）：

	00101101

首先减 1 得到：

	11001101

然后求逆，翻转所有的位：

	00110010

然后将它和原始值做与操作：

	00101101
	00110010
	-------- AND
	00100000

它们唯一的都为 1 的位是最低的 1 位。然后将它和原始值进行异或来清除这个 1 位：

	00101101
	00100000
	-------- XOR
	00001101

这是原始的值，但是已经移除了最低位的 1。

一直重复这个过程直到值全部变为 0。时间复杂度是 **O(s)**，其中 **s** 是 1 位的个数。

## 参考

[位技巧](http://graphics.stanford.edu/~seander/bithacks.html)

*作者：Matthijs Hollemans 翻译：Daisy*


