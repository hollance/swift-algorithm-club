# 最大公因数

两个数字 `a` 和 `b` 的 *最大公因数* （或最大公因子）是 `a` 和 `b` 除以之后没有余数的最大正整数。

例如，`gcd(39, 52) = 13` 因为 13 除 39 （`39/13 = 3） 以及 52 （`52/13 = 4）。没有比 13 更大的可以同时除以他们的数了。

你可能已经在学校的某个阶段学过这个了。:-)

要找到两个数字的 GCD 的费力的地方在先要找出两个数字的因子，然后再找他们共有的最大数。问题就是因子是非常困难的，尤其是当他们非常大的时候。（从正面来看，这个困难也保证了你的在线支付安全）

有一个更聪明的方法来计算 GCD：构建一个算法。思想就是：

	gcd(a, b) = gcd(b, a % b)

`a % b` 计算的是 `a` 被 `b` 除以之后的余数。

下面这个思想的 Swift 实现：

```swift
func gcd(_ a: Int, _ b: Int) -> Int {
  let r = a % b
  if r != 0 {
    return gcd(b, r)
  } else {
    return b
  }
}
```

放到 playground 里并且用下面的例子试试：

```swift
gcd(52, 39)        // 13
gcd(228, 36)       // 12
gcd(51357, 3819)   // 57
```

让我们来一步步看看第三个例子：

	gcd(51357, 3819)

根据 Euclid 的规则，上面的式子等于：

	gcd(3819, 51357 % 3819) = gcd(3819, 1710)

因为 `51357 % 3819` 的余数是 `1710`。如果你计算一下这部分就会得到 `51357 = (13 * 3819) + 1710` 但是我们只关心余数部分。

所以 `gcd(51357, 3819)` 和 `gcd(3819, 1710)` 是一样。这非常有用，因为我们还可以继续简化:

	gcd(3819, 1710) = gcd(1710, 3819 % 1710) = 
	gcd(1710, 399)  = gcd(399, 1710 % 399)   = 
	gcd(399, 114)   = gcd(114, 399 % 114)    = 
	gcd(114, 57)    = gcd(57, 114 % 57)      = 
	gcd(57, 0)

现在不能再继续除了。`114 / 57` 的余数是 0 因为 `114 = 57 * 2` 正好相等。这就以为着我们找到了答案：

	gcd(3819, 51357) = gcd(57, 0) = 57

在每一步 Euclid 的算法中，数字变得越来越小，在某个时候当其中一个变成 0 的时候就结束了。

顺便说一下，两个数字的 GCD 也可能是 1。这就叫做 *互质*。这种情况发生在没有数字可以被那两个数整除，例如：

```swift
gcd(841, 299)     // 1
```

下面是一个有点不一样的 Euclid 算法的实现。与第一个版本不一样的是，这里不实用递归，而是一个简单的 `while` 循环。

```swift
func gcd(_ m: Int, _ n: Int) -> Int {
  var a = 0
  var b = max(m, n)
  var r = min(m, n)

  while r != 0 {
    a = b
    b = r
    r = a % b
  }
  return b
}
```

函数上面的 `max()` 和 `min()` 确保每次我们都是用大的数除以小的数。

## 最小公倍数

与 GCD 相关的一个概念是 *最小公倍数* 或者是 LCM。
 
两个数字 a 和 b 的最小公倍数是两个数的倍数的最小正整数。换句话说，LCM 可以被 `a` 和 `b` 整除。

例如，`lcm(2, 3) = 6` 因为 6 可以被 2 整除也可以被 3 整除。

我们也可以利用 Euclid 的算法来计算 LCM：

	              a * b
	lcm(a, b) = ---------
	            gcd(a, b)

代码：

```swift
func lcm(_ m: Int, _ n: Int) -> Int {
  return m*n / gcd(m, n)
}
```

在 playground 里试试吧：

```swift
lcm(10, 8)    // 40
```

可能在真实世界中根本不需要用到 GCD 或者 LCM，但是看看这些古老的问题还是很有意思的。第一次提出这个问题是在 Euclid 的 [元素](http://publicdomainreview.org/collections/the-first-six-books-of-the-elements-of-euclid-1847/) 中，大概是公元前 300 年的时候。有谣言说是他在破解 Commodore 64 的时候发现了这个算法。

*作者：Matthijs Hollemans 翻译：Daisy*


