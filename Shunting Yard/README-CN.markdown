# 调度场算法

我们写的任何数序都是用一种叫做 *中缀符号* 的符号来表示的。例如：

**A + B * C**

操作符是在两个操作数之间的，因此表达式就被叫成是 *中缀* 形式。如果你仔细想想的话，在纸上写的表达式基本上都是中缀形式的。这就是我们人类能够理解的形式。

乘法比加法有更高的优先级，所以当计算上面的表达式时，首先要将 **B** 乘以 **C**，然后再加上 **A**。人类可以轻松地理解操作符的优先级，但是机器的话就给每个操作符特定的指令。

要改变操作的顺序，可以使用括号：

**(A + B) * C**

现在 **A** 先加上 **B** 然后用和乘以 **C**。

如果想要写一个算法来解析和计算中缀表达式，你就会注意到这是一个非常乏味的过程。需要不断地解析这个表达式来知道那个操作先执行。随着操作符的数量的增加，复杂度也变得越大。

## 后缀表达式

后缀符号，也叫做反向波兰符号或者 RPN，操作符是紧跟在操作数后面的。下面是上面的表达式的后缀表现形式：

**A B C * +**

后缀形式的表达式没有任何括号也不用担心扫描操作符的优先级。这使得用电脑来计算表达式变得简答了，因为需要应用的操作符的顺序是固定的。

用栈来计算一个后缀表达式是很简单的。下面是伪代码：

1. 一个一个地读取后缀表达式的指令
2. 如果指令是一个操作数，将它放入栈中
3. 如果指令是一个二元操作符，
    1. 从栈中取出最上面的两个操作数
    2. 将二元操作符应用于这两个操作数
    3. 将结果放回到栈中
4. 最后，整个后缀表达式的值就在栈中了

利用上面的伪代码，**A B C * +** 的结果是下面这样的：

| Expression    | Stack   |
| ------------- | --------|
| A B C * +     |         |
| B C * +       | A       |
| C * +         | A, B    |
| * +           | A, B, C |
| +             | A, D    |
|               | E       |

其中 **D = B * C** 和 **E = A + D.**

就像上面看到的，后缀操作相对来说简单一些，因为操作符的顺序已经被提前决定好了。

## 将中缀转换成后缀

调度场算法是由 Edsger Dijkstra 发明的来将中缀表达式转换成后缀表达式的算法。许多计算起都是用这个算法来将输入的表达式转成后缀形式。

下面是这个算法的伪代码：

1. 对于所有输入的指令：
    1. 读取下一个指令
    2. 如果指令是一个操作符 (x)
        1. 在操作符的栈顶有一个操作符 (y)，不管 (x) 是左联并且它的优先级小于或等于 (y)，或者(x) 是右联并且它的优先级小于 (y)
            1. 从栈中取出 (y)
            2. 将 (y) 放到输出缓冲区
        2. 将 (x) 放到栈里
    3. 如果指令是一个做括号，那么将它放入栈中
    4. 如果指令是一个右括号
        1. 将栈顶的指令放到输出缓冲区，直到遇见左括号
        2. 同时取出做括号，但是不放到输出缓冲区
    7. 否则将指令放到输出缓冲区
2. 将战中剩下的操作符都放到输出里

让我们来看一个简单的例子，看看伪代码是如何工作的。下面是需要转换的中缀表达式：

**4 + 4 * 2 / ( 1 - 5 )**

下面的表哥描述了每个操作符的优先级和关联性。在算法中也是用的这些。

| Operator | Precedence   | Associativity   |
| ---------| -------------| ----------------|
| ^        | 10           | Right           |
| *        | 5            | Left            |
| /        | 5            | Left            |
| +        | 0            | Left            |
| -        | 0            | Left            |

下面我们开始吧：

| Token | Action                                      | Output            | Operator stack |
|-------|---------------------------------------------|-------------------|----------------|
| 4     | Add token to output                         | 4                 |                |
| +     | Push token to stack                         | 4                 | +              |
| 4     | Add token to output                         | 4 4               | +              |
| *     | Push token to stack                         | 4 4               | * +            |
| 2     | Add token to output                         | 4 4 2             | * +            |
| /     | Pop stack to output, Push token to stack | 4 4 2 *           | / +            |
| (     | Push token to stack                         | 4 4 2 *           | ( / +          |
| 1     | Add token to output                         | 4 4 2 * 1         | ( / +          |
| -     | Push token to stack                         | 4 4 2 * 1         | - ( / +        |
| 5     | Add token to output                         | 4 4 2 * 1 5       | - ( / +        |
| )     | Pop stack to output, Pop stack           | 4 4 2 * 1 5 -     | /  +           |
| end   | Pop entire stack to output                  | 4 4 2 * 1 5 - / + |                |

最后得到的后缀表达式是：

**4 4 2 * 1 5 - / +**

# 参考

[调度场算法 维基百科](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)

*作者： [Ali Hafizji](http://www.github.com/aliHafizji) 翻译：Daisy*
*由 Jaap Wijnen 升级到 Swift 3*


