# 洗牌

目标：重新安排数组中的内容。

想象一下你正在做一个纸牌游戏，你需要洗牌。可以用 `Card` 对象的数组来表示一副牌，洗牌的意思就是改变数组中这些对象的顺序。（就像是排序的反面一样）

下面是 Swift 中简单的实现方法：

```swift
extension Array {
  public mutating func shuffle() {
    var temp = [Element]()
    while !isEmpty {
      let i = random(count)
      let obj = remove(at: i)
      temp.append(obj)
    }
    self = temp
  }
}
```

将代码拷贝到 playground 里来试试：

```swift
var list = [ "a", "b", "c", "d", "e", "f", "g" ]
list.shuffle()
list.shuffle()
list.shuffle()
```

应该可以看到数组中的对象有三个不同的布局 -- 或者用数学语言来说就是 [排列](../Combinatorics/README-CN.markdown) 。


这个洗牌是 *原地* 的，它改变的是原来数组的内容。算法是通过创建一个新的数组，`temp`，初始的时候是空的。然后随机地从原始数组中选择一个元素将它放到 `temp` 里，直到原始数组变为空。最后，再将临时数组拷贝到原来的里面。

> **注意：** `random()` 是返回 0  到给定最大数之间的随机整数的辅助方法。

这个代码虽然可以很好的工作但是并不是很有效率。从数组中移除一个元素是 **O(n)** 的操作，并且我们要执行 **n** 次，使得整个算法变成 **O(n^2)**。我们可以做的更好！

## Fisher-Yates / Knuth 洗牌

下面是一个洗牌算法的改进版本：

```swift
extension Array {
  public mutating func shuffle() {
    for i in stride(from: count - 1, through: 1, by: -1) {
      let j = random(i + 1)
      if i != j {
        swap(&self[i], &self[j])
      }
    }
  }
}
```

再一次随机选择对象。在简单版本中，我们将这些对象放到一个新的临时数组中，这样我们就可以追踪哪些已经洗过了，哪些还没有。然而，在改进的算法中，我们会讲洗过的对象放到原始数组的最后。

> **注意：** 当写 `random(x)` 的时候，返回的最大数是 `x - 1`.我们想要 `j <= i`，而不是 `j < i`，所以从随机数生成器中返回的最大数应该是 `i`，而不是 `i - 1`。这就是为什么我们会 `random(i + 1)`。如果我们不做一个加 1 的补偿，它就会使得一些洗牌的顺序会比其他更容易出现。

让我们来看看这个例子吧。有下面的数组：

	[ "a", "b", "c", "d", "e", "f", "g" ]

循环是从数组的最后开始，从厚往前一直到数组的开头。第一个随机数字可能是整个数组的任何元素，假设它返回的是 2， `c` 的索引。将 `c` 和 `g` 互换让它到数组的最后：

	[ "a", "b", "g", "d", "e", "f" | "c" ]
	             *                    *

现在数组由两部分组成，有 `|` 分隔。竖线右边是已经洗过了的。

下一个随机数是从 0...6 之间选的，所以只能来自 `[ "a", "b", "g", "d", "e", "f" ]` 区域。绝不会选择 `c`，因为这个对象已经完成了洗牌并且我们不会再碰它了。

假设随机数生成器选择的是 0，`a` 的索引。然后我们将 `a` 和 `f` 互换，`f` 是在未洗牌部分的最后一个元素，数组变成这样了：

	[ "f", "b", "g", "d", "e" | "a", "c" ]
	   *                         *

下一个随机数是在 `[ "f", "b", "g", "d", "e" ]` 里的，假设它是 3。将 `d` 和 `e` 互换：

	[ "f", "b", "g", "e" | "d", "a", "c" ]
	                  *     *

一直这样进行下去，直到左边剩下一个元素，例如，像这样：

	[ "b" | "e", "f", "g", "d", "a", "c" ]

没有东西可以和 `"b"` 进行交换了，所以就结束了。

由于一次只查找数组的一个元素，所以这个算法有一个确定的运行时间 **O(n)**。 与你希望的速度一样快！

## 创建一个已经洗过的数组

当想穿件一个新的数组实例包含随机的 `0` 到 `n-1` 的值时，在这个算法的基础会有一些变化。

下面是代码：

```swift
public func shuffledArray(_ n: Int) -> [Int] {
  var a = [Int](repeating: 0, count: n)
  for i in 0..<n {
    let j = random(i + 1)
    if i != j {
      a[i] = a[j]
    }
    a[j] = i
  }
  return a
}
```

使用：

```swift
let numbers = shuffledArray(10)
```

这会返回像 `[3, 0, 9, 1, 8, 5, 2, 6, 7, 4]` 样的东西。就像你看到的，0 到 10 之间的每个数都在里面，但是是随机排列的。当然，当你自己试的时候数字的顺序肯定是不一样的。

`shuffledArray()` 函数首先创建了一个包含 `n` 个 0 的新数组。然后循环 n 次，每一步都是将序列的下一个数组放到数组的随机位置。诀窍就是没有一个数字会被下一个给覆盖掉，所以它把先前的数字先移出！

这个算法非常聪明，我建议你自己要么在纸上要么在 playgrouund 里看看这个算法。（提示：它也是将数组分成两个区域。）

## 参考

这个 Swift 的实现是基于来自 [维基百科文正](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle) 的伪代码。

Mike Bostock 有一个关于洗牌算法的 [伟大的设想](http://bost.ocks.org/mike/shuffle/)。

*作者：Matthijs Hollemans 翻译：Daisy*


