# 堆

堆是数组形式的[二叉树](../Binary%20Tree/README-CN.markdown)，所以它不实用父/子指着恩。树是根据叫做 “堆属性” 的东西部分有序的，堆属性决定了树中节点的顺序。

堆常用于：

- 构建[优先队列](../Priority%20Queue/README-CN.markdown)
- 支持[堆排序](../Heap%20Sort/README-CN.markdown)的数据结构
- 当需要经常计算集合中的最小（或最大）值的时候，堆是很快的
- 让你的非长许愿朋友印象深刻

## 堆属性

有两种类型的堆：*最大堆* 和 *最小堆*。他们是一样的，除了他们存储树节点的顺序是相反的外。

在最大堆中，父节点的值总是比它所有的饿节点都要大。对于最小堆来说，就是另一种方式了：每个父节点的值都比子节点要小。这就叫“堆属性”，对于树中的每个节点来说都是成立的。

一个例子：

![A max-heap](Images/Heap1.png)

这是一个最大堆，因为每个父节点都比它的子节点要大。`(10)` 比 `(7)` 和 `(2)`大。 `(7)` 比 `(5)` 和 `(1)` 大。

这个堆属性的结果是，最大堆的树的根节点存储的始终是最大元素。对于最小堆，根节点始终是树中最小的元素。由于堆经常用作[优先队列](../Priority%20Queue/README-CN.markdown)，优先队列可以让你快速地访问“最重要”的元素，这个时候堆就非常有用了。

> **注意：** 对于堆的排序顺序不能说的再多了。例如，在最大堆中，最大的元素是在索引 0，但是最小的元素并不一定是最后一个 —— 唯一能确定是它在某个叶子节点，但是不知道是哪个。

## 与普通的树相比堆怎么养？

堆的目的不是为了替代二叉搜索树。他们之间有一些相同的地方也有一些不同的地方。下面是一些大的不同：

**节点的顺序** 在[二叉搜索树(BST)](../Binary%20Search%20Tree/README-CN.markdown)中，左节点总是比父节点小，右节点总是比父节点大。对于堆来说这就不对了。在最大堆中，左右节点的值都比父节点要小；在最小堆中，他们比父节点要大。

**内存** 传统的树比他们存储的数据要使用更多的内存。需要分配额外的内存来存储指向左/右子节点的指针。堆只要使用一个数组，并不需要指针。

**平衡** 二叉搜索树必须是“平衡的”，这样大部分的操作才是 **O(log n)** 的。可以随机地插入和删除数据或者使用像是 [AVL 树](../AVL%20Tree/README-CN.markdown) 或者 [红黑树](../Red-Black%20Tree/README-CN.markdown)。但是使用堆的话不需要整棵树都是有序的。只要满足堆属性即可，所以平衡不是一个问题。由于堆的结构化的方式，它可以保证 **O(log n)** 的性能。

**搜索** 搜索一颗二叉树是非常快的 —— 这就是它的主要目的。在堆中，搜索是慢的。堆的目的是将最大（或最小）的节点放在最上面，让插入和删除变得相对快一些。搜索不是最高优先级的。

## 数组中的树

用数组来实现一个类似树的结构看起来有点奇怪，但是它在时间和空间上都是非常有效的。

在上面的例子中，这就是我们要存储它的方式：

	[ 10, 7, 2, 5, 1 ]

这就是全部了！不需要额外的空间只要一个数组就够了。

如果不让用任何指针的话，我们怎么知道哪个是父节点哪个是子节点呢？好问题！在树节点的索引和它的父节点和子节点的索引之间有一个定义良好的关系。

如果 `i` 是某个节点的索引，那么下面的公式就用来计算它的父节点和子节点的索引：

    parent(i) = floor((i - 1)/2)
    left(i)   = 2i + 1
    right(i)  = 2i + 2
    
`right(i)` 只是 `left(i) + 1`。左右节点总是正好彼此挨着。

我们来对例子使用公式来看看。填入数组索引，我们就可以得到父节点和所有节点在数组中的索引：

| 节点 | 数组索引 (`i`) | 父节点索引 | 左节点 | 右节点 |
|------|-------------|--------------|------------|-------------|
| 10 | 0 | -1 | 1 | 2 |
| 7 | 1 | 0 | 3 | 4 |
| 2 | 2 | 0 | 5 | 6 | 
| 5 | 3 | 1 | 7 | 8 |
| 1 | 4 | 1 | 9 | 10 |

自己验证一下这些索引缺失与图中的树一一对应。

> **注意：** 根节点 `(10)` 没有父节点，因为 `-1` 不是一个有效的数组索引。同样的，`(2)`, `(5)`, 和 `(1)` 没有子节点，因为他们的索引比数组的大小要大。所以在我们使用索引前要确保他们是有效的。

回忆一下最大最，父节点的值总是比左右节点的值大（或者等于）。这就意味着对于数组索引 `i` 来说，下面的总是能成立：

```swift
array[parent(i)] >= array[i]
```
	
用上面的堆的例子验证一下这个堆属性。

就像你看到的，这些等式让我们在没有指针的情况下可以找到任何节点的父节点或者子节点的索引。这比只是取消引用稍微复杂一点，但这就是权衡：节省了内存空间但是多了一些额外的计算。幸运的是，这些计算都比较快只花 **O(1)** 的时间。

理解数组索引和在树中的位置是很重要的。下面是一个稍微大点的堆，这棵树有 15 个节点，分成了四层：

![Large heap](Images/LargeHeap.png)

图中的数字不是节点的值，而是存储了节点的数组的索引！这些数组索引和树的不同层级的对应关系是这样的：

![The heap array](Images/Array.png)

为了满足公式，在数组中父节点总是在子节点的前面。这可以在上面的图中看到。

注意到这种模式是有限制的。可以用一颗普通的二叉所做到下面这个但是用堆就不行：

![Impossible with a heap](Images/RegularTree.png)

在当前最低的层级没有完全填满之前不能开始一个新的层级。所以堆的兴中基本上就是这样的：

![The shape of a heap](Images/HeapShape.png)

> **注意：** 技术上来讲，*可以* 用堆来模拟一颗二叉树，但是会浪费一些空间，然后还需要一些方法来将数组的索引标记为空。

突击测验！假设我们有下面的数组：

	[ 10, 14, 25, 33, 81, 82, 99 ]
	
它是一个有效的堆吗？答案是肯定的！一个按低到高排序的数组是一个最小堆。可以画出下面的堆图：

![A sorted array is a valid heap](Images/SortedArray.png)

堆属性适用于每个节点，因为父节点总是比子节点小。（自己验证一下一个从高到低排序的数组是一个有效的最大堆。）

> **注意：** 但不是每一个最小堆都是一个有序的数组！它只以一种方式工作...想要将堆变成一个有序数组，可以使用 [堆排序](../Heap%20Sort/README-CN.markdown)。

## 更多数学

以防你好奇，下面是描述堆的一些特定属性的公式。不需要记住他们，但他们有时会派上用场。可以跳过本正解！

树的 *高度* 是从根节点到最低的子节点要走过的步数。或者更正式地：高度是节点之间的最大边数。高度为 *h* 的堆有 *h + 1* 层。

这个堆的高度是 3，所以它有 4 级：

![Large heap](Images/LargeHeap.png)

有 *n* 个节点的堆的高度是 *h = floor(log_2(n))*。这是因为在添加一个新的层之前会将最低的层填满。例子中有 15 个节点，所以高度是 `floor(log_2(15)) = floor(3.91) = 3`。

如果最低的一层填满了，那么那一层就有 *2^n* 个节点。它上面的树有 *2^h - 1* 个节点。填入例子中的数字：最低层有 8 个节点，就是 `2^3 = 8`。前面三层有 7 个节点，即 `2^3 - 1 = 8 - 1 = 7`。

整个堆中的所有节点数 *n* 就是 *2^(h+1) - 1*。例子中是，`2^4 - 1 = 16 - 1 = 15`。

在 *n* 个元素的堆中，最多有  *ceil(n/2^(h+1))* 个高度 *h* 的节点。

叶子节点总是在数组的索引 *floor(n/2)* 到 *n-1* 的地方。可以利用这点来快速从一个数组来构建一个堆。如果不信的话就用例子验证一下。:-)

只是一些扩展你视野的数学事实。

## 可以用堆做什么？

在插入或者删除元素之后有两个必要的原始操作来保证堆依然是有效的最大或者最小堆：

- `shiftUp()`：如果元素的值比父节点大（最大堆）或者小（最小堆），它就需要与父节点进行交换。这使得它变到树的上面。

- `shiftDown()`：如果元素比它的子节点小（最大堆）或大（最小堆），就需要将它移动到树的下面。这个操作也叫做 "heapify"。

往上或者往下移动是一个需要 **O(log n)** 时间的递归程序。

其他操作都基于这些原始操作。他们是：

- `insert(value)`：将新元素添加到堆的最后，然后用 `shiftUp()` 来修复堆。

- `remove()`：移除并且返回最大值（最大堆）或者最小值（最小堆）。为了填补移除元素之后的洞，将最后的元素移过来然后用 `shiftDown()` 来修复堆。（这有时候也叫做 “提取最小” 或者 “提取最大”）

- `removeAtIndex(index)`：除了它是移除堆中的任意元素而不是根节点之外，跟 `remove()` 是一样的。需要同时调用 `shiftDown()`，假如和它的节点之间无序，和 `shiftUp()`，假如和它的父节点无序的话。

- `replace(index, value)`：用一个更小（最小堆）或者更大（最大堆）的值替换掉原来的值。因为这会使堆属性变得无效，所以要用 `shiftUp()` 来修复堆。（也叫做 “减键” 和 “增键”）

上面所有的操作都是 **O(log n)**，因为往上或者往下移动是他们做的最耗时的操作。还有一些其他的操作需要更多的时间：

- `search(value)`。堆不是为了有效地搜索而构建的，而是 `replace()` 和 `removeAtIndex()` 操作。搜索需要找到节点在数组中的索引，所以先要找到索引。时间是：**O(n)**。

- `buildHeap(array)`：通过不断地调用 `insert()` 来将一个无序数组变成一个堆。如果你聪明的话，这可以在 **O(n)** 时间内完成。

- [Heap sort](../Heap Sort/)。既然堆是一个数组，我们可以用堆的唯一属性来将数组从低到高进行排序。时间：**O(n lg n)**

堆也有一个 `peek()` 方法在不从堆中移除元素时返回最大元素（最大堆）或者最小元素（最小堆），时间：**O(1)**。

> **注意：** 到目前位置，对一个堆经常做的操作是用 `insert()` 来插入新元素和用 `remove()` 来移除最大或者最小值。这两个都需要 **O(log n)** 的时间。其他操作是为了支持更高级的操作而存在的，例如用来构建一个优先队列，以便在元素添加进来之后“重要”的元素可以改变位置。

## 插入到堆中

让我们用一个插入的例子来看看具体的工作细节。插入 `16` 到这个堆中：

![The heap before insertion](Images/Heap1.png)

这个堆的数组是 `[ 10, 7, 2, 5, 1 ]`、

插入新元素的第一步是将它加到数组的最后。数组变成了这样：

	[ 10, 7, 2, 5, 1, 16 ]

这与下面的树对应：

![The heap before insertion](Images/Insert1.png)

`(16)` 添加到了最后一行的第一个可用空间。

不幸的是，已经不再满足堆属性了，因为 `(16)` 上面的 `(2)`，我们是希望它比下面的数字大。（这是最大堆）

为了恢复堆属性，我们要交换 `(16)` 和 `(2)`。

![The heap before insertion](Images/Insert2.png)

我们还没有结束，因为 `(10)` 也比 `(16)` 小。继续交换要插入的元素和它的父节点，直到父节点比它大或者到达树的最顶上。这叫做 **shift-up** 或 **sifting**，是每一个插入操作都要做的。它让太大或者太小的数字 “上浮” 。

最后，我们得到：

![The heap before insertion](Images/Insert3.png)

现在每个父节点都比它的子节点要大了。

向上移动的时间跟树的高度是成比例的，所以它需要 **O(log n)** 的时间。（将节点添加到数组最后的时间是 **O(1)**，所以它没有让操作变慢。）

## 移除根节点

从树中移除 `(10)`：

![The heap before removal](Images/Heap1.png)

上面的空位置该怎么办呢？

![The root is gone](Images/Remove1.png)

当插入的时候，我们是将新值放到数组的最后。这里我们要做相反的事情：将我们有的最后一个对象放到树的顶上，然后再恢复堆属性。

![The last node goes to the root](Images/Remove2.png)

我们来看看如何 **往下移动** `[3]`。为了维持这个对打对的堆属性，我们想要最大的数字在顶上。我们有两个候选的位置用来交换：`(7)` 和 `(2)`。我们选择这三个中最大的一个放在顶上。这就是 `(7)`，所以交换 `(1)` 和 `(7)`，得到下面的树：

![The last node goes to the root](Images/Remove3.png)

继续往下移动直到节点没有任何子节点或者它比所有的子节点都要大。对于我们的堆来说，只要再做一次交换就可以恢复堆属性了：

![The last node goes to the root](Images/Remove4.png)

将所有的都移动到正确地位置需要的时间跟树的高度成正比，所以它需要 **O(log n)** 的时间。

> **注意：** `shiftUp()` 和 `shiftDown()` 一次只能修复一个不在位置的元素。如果有多个元素在错误的地方，需要对每个元素都调用这些方法。

## 移除任何节点

在大多数时候，都是移除堆的根对象，因为堆就是为这个设计的。

然而，如果可以移除任意元素的话是有用的。这是一个 `remove()` 的通用版本，这会涉及到 `shiftDown()` 或 `shiftUp()`。

还用这个树来做举例，移除 `(7)`：

![The heap before removal](Images/Heap1.png)

提醒一下，数组是这样的：

	[ 10, 7, 2, 5, 1 ]

就像你知道的，移除元素会让最大堆或者最小堆变得无效。为了修复这个，我们将我们要移除的元素和最后一个元素交换一下：

	[ 10, 1, 2, 5, 7 ]

最后一个元素是我们要返回的；我们调用 `removeLast()` 来将它从堆中移除。`(1)` 现在是无序的，因为它比它的子节点 `(5)` 要小，但是却在树中更高的一个位置上。我们调用 `shiftDown()` 来修复它。

然而，向下移动操作不是我们需要处理的唯一情况 —— 新元素要往上移动也是可能发生的。想想如果从下面的堆中移除 `(5)` 看看会发生什么：

![We need to shift up](Images/Remove5.png)

现在 `(5)` 和 `(8)` 交换了。 因为 `(8)` 比它的父节点要大，我们需要调用 `shiftUp()`。

## 用数组构建堆

能从数组转成堆的话是很方便的。这只是将数组的元素重新洗一下直到满足堆属性：

代码会是下面这样的：

```swift
  private mutating func buildHeap(fromArray array: [T]) {
    for value in array {
      insert(value)
    }
  }
```

只是对数组中的每个值调用 `insert()` 方法。非常简单，但是不是很有效率。这总共需要 **O(n log n)** 的时间，因为有 **n** 个元素，每个插入都需要 **log n** 的时间。

如果你没有看关于数学的那一部分，那你也应该知道对于任何堆来说，在数组索引 *n/2* 到 *n-1* 的元素是树的叶子。我们可以先跳过这些叶子。我们只处理其他节点，因为他们是有一个或者多个子节点的父节点，所以他们可能在错误的位置。

代码：

```swift
  private mutating func buildHeap(fromArray array: [T]) {
    elements = array
    for i in (elements.count/2 - 1).stride(through: 0, by: -1) {
      shiftDown(index: i, heapSize: elements.count)
    }
  }
```

这里 `elements` 是堆本身的数组。我们从后遍历这个数组，最第一个非叶子节点开始，然后调用 `shiftDown()`。这个简单的循环将这些节点以及我们跳过的叶子放到正确的位置。这就是 Floyd's 算法，只需要 **O(n)** 的时间。胜利！

## 搜索堆

堆不是为快速搜索而设计的，但是如果要用 `removeAtIndex()` 移除任意元素或者用 `replace()` 改变元素的值，那么无论如何都需要先获得元素的索引。搜索是一种实现这个的方法但是优点慢。

在[二叉搜索树](../Binary%20Search%20Tree/README-CN.markdown)中可以依赖节点的顺序来确保一个快速的搜索。堆用不同的方法来排序节点，所以二叉搜索不管用。必须要查找树中的每个节点。

再拿我们的堆来举例：

![The heap](Images/Heap1.png)

如果想要搜索节点 `(1)` 的索引，可以用线性搜索来遍历数组 `[ 10, 7, 2, 5, 1 ]`。

但是即使堆属性没有考虑进来，我们也可以利用它的优势。我们知道在最大堆中父节点总是比子节点要大，所以我们可以忽略这些父节点已经被我们要找的值小的节点子节点（以及他们的子节点）。

假如我们想要看看堆中是否包含值 `8`（它不包含）。从根节点 `(10)` 开始。这显然不是我们要找的，所以我们递归地查找它的左右节点。左节点是 `(7)`。这也不是我们要找的，但是既然它是最大堆，就没有必要再找 `(7)` 的子节点了。他们始终都比 `(7)` 小，所以也不会等于 `8`。对于右节点 `(2)` 来说也是一样的。

尽管这是一个小的优化，搜索还是 **O(n)** 的操作。

> **注意：** 有一个方法可以让搜索变成 **O(1)** 的操作，这就是用一个字典来映射值和索引的关系。如果需要经常调用 `replace()` 来改变[优先队列](../Priority%20Queue/README-CN.markdown)中的对象的 “优先级” 话，这就值得做。

## 代码

查看 [Heap.swift](Heap.swift) 来看看 Swift 中这些概念的实现。大部分代码都是非常直接的。唯一棘手的是 `shiftUp()` 和 `shiftDown()`。

你已经知道有两种类型的堆：最大堆和最小堆。他们之间位移的不同是他们怎么安排节点的顺序：最大的在第一个或者最小的在第一个。

只有一个 `Heap` 对象并且它有一个 `isOrderedBefore()` 闭包，而不是创建两个不同的版本，`MaxHeap` 和 `MinHeap`。这个闭包包含决定两个值的顺序的逻辑。你可能以前也见过这个，因为 Swfit 的 `sort()` 函数就是这样做的。

为了构建一个整数的最大堆，这样写：

```swift
var maxHeap = Heap<Int>(sort: >)
```

构建最小堆，这样写：

```swift
var minHeap = Heap<Int>(sort: <)
```

我只是将这个指出来，因为大部分堆的实现都是用 `<` 和 `>` 操作符来比较值，而这里用的是 `isOrderedBefore()` 闭包。

## 参考

[堆 维基百科](https://en.wikipedia.org/wiki/Heap_%28data_structure%29)

*作者 [Kevin Randrup](http://www.github.com/kevinrandrup) 和 Matthijs Hollemans 翻译：Daisy*


